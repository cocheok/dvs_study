{
    "docs": [
        {
            "location": "/", 
            "text": "Objetivo\n\n\nEl presente proyecto tiene como objetivo la investigaci\u00f3n de algoritmos para explotar la informaci\u00f3n provista por sensores de visi\u00f3n din\u00e1mica (DVS)\n\n\nAlcance\n\n\nDise\u00f1ar y desarrollar el software base del sistema experimental: Este punto se enfoca en dise\u00f1ar la arquitectura correspondiente en cuanto a t\u00e9cnicas y tecnolog\u00edas utilizadas para la realizaci\u00f3n del software base sobre el cual se probar\u00e1n los algoritmos que explotan la informaci\u00f3n provista por dichas camaras.\n\n\nDesarrollar de la estructura de proyecto libre: Este punto se enfoca en decidir e implementar las herramientas y tecnolog\u00edas para que sea un proyecto de desarrollo libre y contributivo.\n\n\nDesarrollar la estructura de simulaci\u00f3n: Dado que en futuras investigaciones habr\u00e1 que decidir que hardware utilizar y por el propio proceso de desarrollo, se realizar\u00e1n los test de esta tecnolog\u00eda en una plataforma simulada ( realizada con Gazebo o similar ). Esto agrega un nivel de abstracci\u00f3n al desarrollo, y dar\u00e1 independencia con respecto del hardware utilizado.", 
            "title": "Inicio"
        }, 
        {
            "location": "/#objetivo", 
            "text": "El presente proyecto tiene como objetivo la investigaci\u00f3n de algoritmos para explotar la informaci\u00f3n provista por sensores de visi\u00f3n din\u00e1mica (DVS)", 
            "title": "Objetivo"
        }, 
        {
            "location": "/#alcance", 
            "text": "Dise\u00f1ar y desarrollar el software base del sistema experimental: Este punto se enfoca en dise\u00f1ar la arquitectura correspondiente en cuanto a t\u00e9cnicas y tecnolog\u00edas utilizadas para la realizaci\u00f3n del software base sobre el cual se probar\u00e1n los algoritmos que explotan la informaci\u00f3n provista por dichas camaras.  Desarrollar de la estructura de proyecto libre: Este punto se enfoca en decidir e implementar las herramientas y tecnolog\u00edas para que sea un proyecto de desarrollo libre y contributivo.  Desarrollar la estructura de simulaci\u00f3n: Dado que en futuras investigaciones habr\u00e1 que decidir que hardware utilizar y por el propio proceso de desarrollo, se realizar\u00e1n los test de esta tecnolog\u00eda en una plataforma simulada ( realizada con Gazebo o similar ). Esto agrega un nivel de abstracci\u00f3n al desarrollo, y dar\u00e1 independencia con respecto del hardware utilizado.", 
            "title": "Alcance"
        }, 
        {
            "location": "/project/structure/", 
            "text": "DevOps\n\n\nLa estructura a utilizar es la que se encuentra detallada \naqui\n\n\nSoftware\n\n\nEl desarrollo de software consiste tomar las librerias publicadas por \nRobotics perception Group\n adaptarlas a los flujos de Node-Red\nEn el caso del nodo de ROS \ndvs_ros_driver\n se crea un nodo de Node-Red bajo la categoria DVS128\n\n\n\n\nDicha adaptaci\u00f3n se realiza utilizando la libreria de NodeJS \nrosjs\n que es la que realiza la comunicaci\u00f3n con el roscore a traves de \nrosbridge\n y manteniendo el prefijo \nnode-red-\n como nombre del proyecto de NodeJS de npm realizado.\n\n\nHardware\n\n\nEl dispositivo utilizado en este proyecto es una c\u00e1mara DVS128 desarrollada por \nIniLabs\n.", 
            "title": "Estructura"
        }, 
        {
            "location": "/project/structure/#devops", 
            "text": "La estructura a utilizar es la que se encuentra detallada  aqui", 
            "title": "DevOps"
        }, 
        {
            "location": "/project/structure/#software", 
            "text": "El desarrollo de software consiste tomar las librerias publicadas por  Robotics perception Group  adaptarlas a los flujos de Node-Red\nEn el caso del nodo de ROS  dvs_ros_driver  se crea un nodo de Node-Red bajo la categoria DVS128   Dicha adaptaci\u00f3n se realiza utilizando la libreria de NodeJS  rosjs  que es la que realiza la comunicaci\u00f3n con el roscore a traves de  rosbridge  y manteniendo el prefijo  node-red-  como nombre del proyecto de NodeJS de npm realizado.", 
            "title": "Software"
        }, 
        {
            "location": "/project/structure/#hardware", 
            "text": "El dispositivo utilizado en este proyecto es una c\u00e1mara DVS128 desarrollada por  IniLabs .", 
            "title": "Hardware"
        }, 
        {
            "location": "/project/base/", 
            "text": "Demo 1\n\n\nEl software de demostraci\u00f3n consiste en el reconocimiento de un tablero de ajedrez dada una grabaci\u00f3n. \n\n\nLa estructura l\u00f3gica del mismo se compone de:\n\n\n\n\nUna base de datos de objetos conocidos en los cuales almacene el flujo de eventos necesarios para el reconocimiento un tablero de ajedrez. \n\n\nUn nodo de Mock que lo que haga sea leer el archivo AER provisto por la camara DVS 128 que simule la camara conectada.\n\n\nUn nodo de reconocimiento cuya entrada sea el flujo de eventos y su salida un booleano, true en el caso de que lo reconozca.\n\n\nUn nodo que imprima el resultado en la pantalla de debug de Node-Red .\n\n\n\n\nDicha estructura se puede visualizar en el siguiente diagrama:\n\n\n\n\nEl flujo inicia cuando se recibe como entrada una grabaci\u00f3n de una c\u00e1mara DVS128 (AER File) en un nodo DVS-Reader que tiene el fin de enviarle el flujo de eventos registrados en la grabaci\u00f3n a un nodo llamado Chessboard Recognition Alghoritm, que realiza un algoritmo de reconocimiento de un tablero de ajedrez y retorna un booleano con el valor true en el caso de que lo reconozca. Para ello debemos realizar un flujo de Node-Red tendr\u00eda la siguiente forma:\n\n\n\n\nEl nodo AER File lo que hace es enviar la informaci\u00f3n del archivo dado en forma serializada simulando ser la c\u00e1mara DVS128.\nEl nodo Chessboard Recognition Alghoritm lo que hace es conectarse a un nodo de ros informando los datos que recibe un nodo de ROS que detecta el tablero de ajedrez del flujo de eventos recibidos y luego ni bien lo tiene identificado devuelve true el cual es logueado en la consola de debug que provee la herramienta.\n\n\nDemo 2\n\n\nEl software de demostraci\u00f3n consiste en el reconocimiento de un tablero de ajedrez con la c\u00e1mara DVS128.\n\n\nSi reemplazamos el nodo AER File del Demo1 por un nodo real que tenga los controladores de la c\u00e1mara DVS128 y conectando la misma al dispositivo en el que se encuentre corriendo el servicio de Node-Red, se puede utilizar el nodo Chessboard Recognition Alghoritm. Siendo el flujo de la siguiente forma:", 
            "title": "Pruebas"
        }, 
        {
            "location": "/project/base/#demo-1", 
            "text": "El software de demostraci\u00f3n consiste en el reconocimiento de un tablero de ajedrez dada una grabaci\u00f3n.   La estructura l\u00f3gica del mismo se compone de:   Una base de datos de objetos conocidos en los cuales almacene el flujo de eventos necesarios para el reconocimiento un tablero de ajedrez.   Un nodo de Mock que lo que haga sea leer el archivo AER provisto por la camara DVS 128 que simule la camara conectada.  Un nodo de reconocimiento cuya entrada sea el flujo de eventos y su salida un booleano, true en el caso de que lo reconozca.  Un nodo que imprima el resultado en la pantalla de debug de Node-Red .   Dicha estructura se puede visualizar en el siguiente diagrama:   El flujo inicia cuando se recibe como entrada una grabaci\u00f3n de una c\u00e1mara DVS128 (AER File) en un nodo DVS-Reader que tiene el fin de enviarle el flujo de eventos registrados en la grabaci\u00f3n a un nodo llamado Chessboard Recognition Alghoritm, que realiza un algoritmo de reconocimiento de un tablero de ajedrez y retorna un booleano con el valor true en el caso de que lo reconozca. Para ello debemos realizar un flujo de Node-Red tendr\u00eda la siguiente forma:   El nodo AER File lo que hace es enviar la informaci\u00f3n del archivo dado en forma serializada simulando ser la c\u00e1mara DVS128.\nEl nodo Chessboard Recognition Alghoritm lo que hace es conectarse a un nodo de ros informando los datos que recibe un nodo de ROS que detecta el tablero de ajedrez del flujo de eventos recibidos y luego ni bien lo tiene identificado devuelve true el cual es logueado en la consola de debug que provee la herramienta.", 
            "title": "Demo 1"
        }, 
        {
            "location": "/project/base/#demo-2", 
            "text": "El software de demostraci\u00f3n consiste en el reconocimiento de un tablero de ajedrez con la c\u00e1mara DVS128.  Si reemplazamos el nodo AER File del Demo1 por un nodo real que tenga los controladores de la c\u00e1mara DVS128 y conectando la misma al dispositivo en el que se encuentre corriendo el servicio de Node-Red, se puede utilizar el nodo Chessboard Recognition Alghoritm. Siendo el flujo de la siguiente forma:", 
            "title": "Demo 2"
        }, 
        {
            "location": "/project/calibration/", 
            "text": "Calibraci\u00f3n\n\n\nPara la calibraci\u00f3n utilizamos el modulo de ros desarrollado por \nRobotics and Perception group\n. La calibraci\u00f3n requiere un tablero con una grilla regular de LEDs parpadeando. El nuestro caso utilizamos la grilla \nModulo Max7219 Dot Led Matrix 8x8 Arduino/pic\n\n\n \n\n\nLa misma la controlamos desde un \nArduino MEGA 2560 R3\n\n\n\n\nConfiguramos los siguientes parametros en \ndvs_calibration\n: \n\n\n\n\n\n\ndots_w\n: Numero de filas LED\n\n\n\n\n\n\ndots_h\n: Numero de columnas LED\n\n\n\n\n\n\ndot_distance\n: distancia en metros entre los LED en \nmetros\n\n\n\n\n\n\nblinking_time_us\n: tiempo de parpadeo en \nmicro\n-segundos\n\n\n\n\n\n\nblinking_time_tolerance_us\n: Es la tolerancia en micro-segundos para contar la transici\u00f3n\n\n\n\n\n\n\nminimum_transitions_threshold\n: Es el n\u00famero m\u00ednimo de transiciones necesarias a considerar en la b\u00fasqueda de los LED.\n\n\n\n\n\n\nminimum_led_mass\n: Es la m\u00ednima \"masa\" de una burbuja LED, es decir, la suma de las transiciones en este Blop\n\n\n\n\n\n\npattern_search_timeout\n: Es el tiempo de espera en segundos cuando el mapa de transici\u00f3n es reiniciado (que tambi\u00e9n se pone a cero cuando se encontr\u00f3 la matriz de LED)", 
            "title": "Calibraci\u00f3n"
        }, 
        {
            "location": "/project/calibration/#calibracion", 
            "text": "Para la calibraci\u00f3n utilizamos el modulo de ros desarrollado por  Robotics and Perception group . La calibraci\u00f3n requiere un tablero con una grilla regular de LEDs parpadeando. El nuestro caso utilizamos la grilla  Modulo Max7219 Dot Led Matrix 8x8 Arduino/pic     La misma la controlamos desde un  Arduino MEGA 2560 R3   Configuramos los siguientes parametros en  dvs_calibration :     dots_w : Numero de filas LED    dots_h : Numero de columnas LED    dot_distance : distancia en metros entre los LED en  metros    blinking_time_us : tiempo de parpadeo en  micro -segundos    blinking_time_tolerance_us : Es la tolerancia en micro-segundos para contar la transici\u00f3n    minimum_transitions_threshold : Es el n\u00famero m\u00ednimo de transiciones necesarias a considerar en la b\u00fasqueda de los LED.    minimum_led_mass : Es la m\u00ednima \"masa\" de una burbuja LED, es decir, la suma de las transiciones en este Blop    pattern_search_timeout : Es el tiempo de espera en segundos cuando el mapa de transici\u00f3n es reiniciado (que tambi\u00e9n se pone a cero cuando se encontr\u00f3 la matriz de LED)", 
            "title": "Calibraci\u00f3n"
        }, 
        {
            "location": "/project/contribute/", 
            "text": "Como contribuir\n\n\nPara contribuir con mas software de testeo o investigaciones envi\u00e1 un mail a talkwithme@jberrettamoreno.com", 
            "title": "Como contribuir"
        }, 
        {
            "location": "/project/contribute/#como-contribuir", 
            "text": "Para contribuir con mas software de testeo o investigaciones envi\u00e1 un mail a talkwithme@jberrettamoreno.com", 
            "title": "Como contribuir"
        }, 
        {
            "location": "/references/", 
            "text": "Low-latency event-based visual odometry\n\n\nWeb del proyecto\n\n\nPaper\n\n\nLow-latency localization by Active LED Markers tracking using a Dynamic Vision Sensor\n\n\nPresentaci\u00f3n\n\n\nC\u00f3digo\n\n\nPoker-DVS and MNIST-DVS\n\n\nWeb del proyecto\n\n\nProfesionales referentes\n\n\nTobi Delbr\u00fcck\n\n\nP\u00e1gina personal\n\n\nBernab\u00e9 Linares-Barranco\n\n\nP\u00e1gina personal\n\n\nAndrea Censi\n\n\nP\u00e1gina personal\n\n\nInvestigaciones\n\n\nP\u00e1gina principal\n\n\ndvs\n\n\nSoftware\n\n\nLibrerias\n\n\nDatasets\n\n\nOtros\n\n\nOpen source robot\n\n\nGet start DVS\n\n\nScripts DVS\n\n\nHardware DVS", 
            "title": "Referencias"
        }, 
        {
            "location": "/references/#low-latency-event-based-visual-odometry", 
            "text": "Web del proyecto  Paper", 
            "title": "Low-latency event-based visual odometry"
        }, 
        {
            "location": "/references/#low-latency-localization-by-active-led-markers-tracking-using-a-dynamic-vision-sensor", 
            "text": "Presentaci\u00f3n  C\u00f3digo", 
            "title": "Low-latency localization by Active LED Markers tracking using a Dynamic Vision Sensor"
        }, 
        {
            "location": "/references/#poker-dvs-and-mnist-dvs", 
            "text": "Web del proyecto", 
            "title": "Poker-DVS and MNIST-DVS"
        }, 
        {
            "location": "/references/#profesionales-referentes", 
            "text": "", 
            "title": "Profesionales referentes"
        }, 
        {
            "location": "/references/#tobi-delbruck", 
            "text": "P\u00e1gina personal", 
            "title": "Tobi Delbr\u00fcck"
        }, 
        {
            "location": "/references/#bernabe-linares-barranco", 
            "text": "P\u00e1gina personal", 
            "title": "Bernab\u00e9 Linares-Barranco"
        }, 
        {
            "location": "/references/#andrea-censi", 
            "text": "P\u00e1gina personal", 
            "title": "Andrea Censi"
        }, 
        {
            "location": "/references/#investigaciones", 
            "text": "P\u00e1gina principal  dvs", 
            "title": "Investigaciones"
        }, 
        {
            "location": "/references/#software", 
            "text": "Librerias  Datasets", 
            "title": "Software"
        }, 
        {
            "location": "/references/#otros", 
            "text": "Open source robot  Get start DVS  Scripts DVS  Hardware DVS", 
            "title": "Otros"
        }
    ]
}